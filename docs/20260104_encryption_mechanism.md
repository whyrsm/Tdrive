# Metadata Encryption Mechanism

## Overview

Telebox prioritizes user privacy by ensuring that sensitive metadata, specifically **file names** and **folder names**, are encrypted at rest in the database. This prevents database administrators or anyone with access to the raw database from reading the content structure of a user's drive.

This document details the technical implementation of this encryption mechanism, which is handled primarily by the `CryptoService` in the backend.

## 1. Per-User Key Derivation

A critical security feature of Telebox is that **there is no single master key** for user data. Instead, each user has a unique encryption key derived from their own Telegram session.

*   **Source:** The key is derived from the user's **raw (decrypted) Telegram session string**. This session string acts as a stable, user-specific secret that is already required for the user to access their account.
*   **Derivation Method:** We use `SHA-256` to hash the session string.
    ```typescript
    // Backend: src/common/services/crypto.service.ts
    deriveKeyFromSession(rawSessionString: string): Buffer {
      return createHash('sha256').update(rawSessionString).digest();
    }
    ```
*   **Result:** A consistent 32-byte (256-bit) key that is unique to the user.

## 2. Encryption Algorithm

We use **AES-256-GCM** (Galois/Counter Mode) for all metadata encryption. GCM is an authenticated encryption mode that provides both confidentiality (encryption) and integrity (ensuring data hasn't been tampered with).

*   **Cipher:** `aes-256-gcm`
*   **Key Size:** 256 bits (32 bytes)
*   **IV (Initialization Vector):** 96 bits (12 bytes), randomly generated for *every* encryption operation.
*   **Auth Tag:** 128 bits (16 bytes), generated by the GCM algorithm.

## 3. Storage Format

The encrypted data is stored in the PostgreSQL database as a single string field (e.g., `File.name`, `Folder.name`). To ensure we can properly decrypt it later, we concatenate the IV, the Authentication Tag, and the Encrypted Data (Ciphertext) into a single string using `:` as a separator.

**Format:**
```
iv:authTag:encryptedData
```
*All parts are Hex-encoded strings.*

*   **iv**: 12 bytes (24 hex characters)
*   **authTag**: 16 bytes (32 hex characters)
*   **encryptedData**: Variable length (hex characters)

## 4. Process Flow

### Visual Overview

```text
                                   ┌──────────────────┐
                                   │  Master Key (Env)│
                                   └────────┬─────────┘
                                            │
┌─────────────────────────┐        ┌────────▼─────────┐
│ Encrypted Session (DB)  │───────▶│  Decrypt Session │
└─────────────────────────┘        └────────┬─────────┘
                                            │
                                            ▼
                                   ┌──────────────────┐
                                   │   Raw Session    │
                                   └────────┬─────────┘
                                            │
                                         SHA-256
                                            │
                                            ▼
┌─────────────────┐                ┌──────────────────┐
│  Plaintext Name │───────────────▶│    User Key      │
└─────────────────┘                └────────┬─────────┘
                                            │
                                            ▼
┌─────────────────┐                ┌──────────────────┐
│   Random IV     │───────────────▶│   AES-256-GCM    │
└─────────────────┘                └────────┬─────────┘
                                            │
                                            ▼
                                  ┌────────────────────┐
                                  │ Encrypted Output   │
                                  ├──────────┬─────────┤
                                  │ Cipher   │ AuthTag │
                                  └─────┬────┴────┬────┘
                                        │         │
                                        ▼         ▼
                           ┌─────────────────────────────────────┐
                           │ Format:  iv : authTag : ciphertext  │
                           └─────────────────────────────────────┘
```

### Encryption (Write)
When a user uploads a file or creates a folder:
1.  **Retrieve Session:** The backend retrieves the user's encrypted session string from the database.
2.  **Decrypt Session:** The session string is decrypted using the server's master `ENCRYPTION_KEY`.
3.  **Derive User Key:** The `SHA-256` hash of the *decrypted* session string is calculated.
4.  **Encrypt Metadata:**
    *   A new random 12-byte IV is generated.
    *   The file/folder name is encrypted using the derived User Key and the IV.
    *   An Auth Tag is computed.
5.  **Store:** The result is formatted as `iv:authTag:ciphertext` and saved to the database.

### Decryption (Read)
When a user lists their files or folders:
1.  **Retrieve Data:** The backend queries the database for the user's files/folders.
2.  **Derive User Key:** (Same as above) The User Key is derived from the user's session.
3.  **Parse Data:** The stored name string is split by `:` into IV, Auth Tag, and Ciphertext.
4.  **Decrypt Metadata:**
    *   The `Decipher` is initialized with the User Key and the extracted IV.
    *   The Auth Tag is set to verify integrity.
    *   The ciphertext is decrypted back to the original plaintext name.
5.  **Response:** The decrypted names are sent to the frontend.

## 5. Security Benefits

1.  **Unique IVs:** Because a random IV is used for every single encryption, encrypting the same filename twice (e.g., two folders named "Documents") results in completely different stored strings. This prevents statistical analysis of the encrypted data.
2.  **Tamper Evidence:** The GCM Auth Tag ensures that if an attacker modifies the encrypted string in the database, the decryption process will throw an error rather than producing garbage data.
3.  **No Master Key Exposure:** The keys used to encrypt user filenames are never stored directly in the database. They can only be derived transiently when the user is authenticated (since the session string is needed), and the session string itself is encrypted at rest.
